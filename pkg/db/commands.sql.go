// Code generated by sqlc. DO NOT EDIT.
// source: commands.sql

package db

import (
	"context"
)

const deleteCommand = `-- name: DeleteCommand :exec
DELETE FROM commands
  WHERE channel_name = $1
  AND name = $2
`

type DeleteCommandParams struct {
	ChannelName string
	Name        string
}

func (q *Queries) DeleteCommand(ctx context.Context, arg DeleteCommandParams) error {
	_, err := q.db.ExecContext(ctx, deleteCommand, arg.ChannelName, arg.Name)
	return err
}

const getCommand = `-- name: GetCommand :one
SELECT template
  FROM commands
  WHERE name = $2
  AND channel_name = $1
`

type GetCommandParams struct {
	ChannelName string
	Name        string
}

func (q *Queries) GetCommand(ctx context.Context, arg GetCommandParams) (string, error) {
	row := q.db.QueryRowContext(ctx, getCommand, arg.ChannelName, arg.Name)
	var template string
	err := row.Scan(&template)
	return template, err
}

const getCommands = `-- name: GetCommands :many
SELECT name
  FROM commands
  WHERE channel_name = $1
  ORDER BY name ASC
`

func (q *Queries) GetCommands(ctx context.Context, channelName string) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, getCommands, channelName)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var name string
		if err := rows.Scan(&name); err != nil {
			return nil, err
		}
		items = append(items, name)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMatchingCommands = `-- name: GetMatchingCommands :many
SELECT template, name, ($1::text ~ name)::bool as Match
  FROM commands
  WHERE channel_name = $2
`

type GetMatchingCommandsParams struct {
	Message     string
	ChannelName string
}

type GetMatchingCommandsRow struct {
	Template string
	Name     string
	Match    bool
}

func (q *Queries) GetMatchingCommands(ctx context.Context, arg GetMatchingCommandsParams) ([]GetMatchingCommandsRow, error) {
	rows, err := q.db.QueryContext(ctx, getMatchingCommands, arg.Message, arg.ChannelName)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetMatchingCommandsRow
	for rows.Next() {
		var i GetMatchingCommandsRow
		if err := rows.Scan(&i.Template, &i.Name, &i.Match); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const setCommand = `-- name: SetCommand :exec
INSERT INTO commands (channel_name, name, template)
  VALUES ($1, $2, $3)
  ON CONFLICT
  ON CONSTRAINT command_pkey DO UPDATE
  SET template = $3
`

type SetCommandParams struct {
	ChannelName string
	Name        string
	Template    string
}

func (q *Queries) SetCommand(ctx context.Context, arg SetCommandParams) error {
	_, err := q.db.ExecContext(ctx, setCommand, arg.ChannelName, arg.Name, arg.Template)
	return err
}
